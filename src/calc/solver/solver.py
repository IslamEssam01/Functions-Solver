import numpy as np
from ..lexer.lexer import Lexer
from ..parser.parser import Parser
from ..evaluator.evaluator import Evaluator
from ..ast.ast import *

from scipy.optimize import brentq
from sympy import ConditionSet, symbols,  S, solveset, Expr, Eq, simplify, Union, ImageSet, FiniteSet
from typing import Callable


# sympy solveset have a bug with sqrt so we omit it for now
# def find_roots_symbolically(diff_expr: Expr) -> list[float]:
#     """
#     Find the roots of a symbolic expression using sympy.
#
#     Args:
#         diff_expr (Expr): The symbolic expression whose roots are to be found.
#
#     Returns:
#         list[ float]: A list of roots found symbolically.
#     """
#
#     x = symbols("x", real=True)
#     solutions = solveset(Eq(diff_expr, 0), x, domain=S.Reals)
#
#
#     # If no solutions or the solutions is a condition set return []
#     # A condition set is a set of elements which satisfies a given condition
#     # it can be solved over a range but numerical solutions are mostly faster
#     if not solutions or isinstance(solutions, ConditionSet):
#         return []
#
#     # If the solutions are a union of multiple sets, handle each part separately
#     parts = solutions.args if isinstance(solutions, Union) else [solutions]
#
#     # If any part is a condition set we prefer numerical solutions
#     if any(isinstance(part, ConditionSet)for part in parts):
#         return []
#
#     all_solutions = []
#
#     for part in parts:
#         # If the solution is an ImageSet, it represents a set of solutions generated by a lambda function
#         if isinstance(part, ImageSet):
#             lam = part.lamda
#             variables = lam.variables
#             expr = lam.expr
#             base_set = part.base_set
#
#             # If the base set is integers and there is one variable, substitute integer values
#             if base_set == S.Integers and len(variables) == 1:
#                 var = variables[0]
#                 for n_val in range(-2, 3):
#                     sol = expr.subs(var, n_val)
#                     numerical_sol = sol.evalf()
#                     all_solutions.append(numerical_sol)
#
#         # If the solution is a finite set, extend the list with these solutions
#         elif isinstance(part, FiniteSet):
#             all_solutions.extend(part)
#
#     # Convert roots to be floats and return the middle 8 of them if there is more than 8
#     roots: list[float] = sorted(list(set(map(float, all_solutions))))
#     middle_index = len(roots) // 2
#     start_index = max(0, middle_index - 4)
#     end_index = start_index + 8
#     return roots[start_index:end_index]


def find_roots_numerically(diff_func: Callable[[int | float], int | float],  range_scale=3) -> list[float]:
    """
    Find the roots of a numerical function using the Brent method.

    Args:
        diff_func (Callable[[int | float], int | float]): The numerical function whose roots are to be found.
        range_scale (int, optional): The scale of the range to search for roots. Defaults to 3.

    Returns:
        list[int | float]: A list of roots found numerically.
    """

    roots: list[float] = []
    num_intervals = 10000*range_scale
    x_intervals = np.linspace(
        -1000*range_scale, 1000*range_scale, num_intervals+1)

    for i in range(len(x_intervals)-1):
        left, right = x_intervals[i], x_intervals[i+1]

        try:
            # Check if there is a sign change in the interval
            if diff_func(left) * diff_func(right) <= 0:
                try:
                    # Use Brent's method to find the root
                    result = brentq(diff_func, left, right)
                    root = result[0] if isinstance(
                        result, tuple) else result
                    roots.append(float(root))
                except ValueError:
                    pass
        except:
            pass

    roots = sorted(list(set(roots)))

    middle_index = len(roots) // 2
    start_index = max(0, middle_index - 4)
    end_index = start_index + 8
    return roots[start_index:end_index]


def parse_expression(expresiion):
    """
    Parse a mathematical expression into an abstract syntax tree (AST).

    Args:
        expression (str): The mathematical expression to parse.

    Returns:
        AST: The parsed abstract syntax tree.
    """

    lexer = Lexer(expresiion)
    parser = Parser(lexer.tokens)
    return parser.parse()


def solve(f1: str, f2: str) -> tuple[list[float], bool]:
    """
    Solve for the intersection points of two functions.

    Args:
        f1 (str): The first function as a string.
        f2 (str): The second function as a string.

    Returns:
        tuple[list[float], bool]: A tuple containing a list of intersection points and a boolean indicating if the functions are the same.
    """

    f1_ast = parse_expression(f1)
    f2_ast = parse_expression(f2)

    # Create a new AST representing the difference of the two functions
    # f1=f2 -> f1-f2=0
    diff_ast = InfixExpression(f1_ast, "-", f2_ast)
    diff_eval = Evaluator(diff_ast).evaluate
    diff_expr = diff_ast.to_sympy_expr()

    # If the simplified difference expression is zero, the functions are identical
    if simplify(diff_expr) == 0:
        return [], True

    intersection_points = []
    # sympy solveset have a bug with sqrt so we omit it for now
    # try:
    #     intersection_points = find_roots_symbolically(diff_expr)
    # except:
    #     pass

    # If the symbolic method fails, use numerical method
    if not intersection_points:
        intersection_points = find_roots_numerically(diff_eval)

    return intersection_points, False
